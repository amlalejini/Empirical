/**
 *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
 *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
 *  @date 2019
 *
 *  @file  AST.h
 *  @brief AST nodes generated by Emphatic.
 **/

#include "ElementInfo.h"

/// All AST Nodes have a common base class.
struct AST_Node {
  virtual ~AST_Node() { ; }
  /// Echo the original code passed into each class.
  virtual void PrintEcho(std::ostream &, const std::string & prefix) const = 0;
  virtual void PrintOutput(std::ostream &, const std::string & prefix) const = 0;
};

/// AST Node for a new scope level.
struct AST_Scope : AST_Node {
  emp::vector<emp::Ptr<AST_Node>> children;
  ~AST_Scope() { for (auto x : children) x.Delete(); }

  /// Create a new child (of a specified type) in this scope.
  template <typename T>
  T & NewChild() {
    auto node_ptr = emp::NewPtr<T>();  ///< Build the new AST node.
    children.push_back(node_ptr);      ///< Save it as a child in the current scope.
    return *node_ptr;                  ///< Return a reference to the new child.
  }

  /// Scope should run echo on each of its children.
  void PrintEcho(std::ostream & os, const std::string & prefix) const override {
    for (auto x : children) { x->PrintEcho(os, prefix); }
  }

  /// Scope should run output on each of its children.
  void PrintOutput(std::ostream & os, const std::string & prefix) const override {
    for (auto x : children) { x->PrintOutput(os, prefix); }
  }
};

/// AST Node for arbitrary code (these shouldn't be needed when parsing techniques improve)
struct AST_Code : public AST_Node {
  std::string code;

  /// Scope should run echo on each of its children.
  void PrintEcho(std::ostream & os, const std::string & prefix) const override {
    os << prefix << code;
  }

  /// Scope should run output on each of its children.
  void PrintOutput(std::ostream & os, const std::string & prefix) const override {
    os << prefix << code;
  }
};

/// AST Node for Pre-processor code. (These should probably be dealt with in a first pass)
struct AST_PP : public AST_Code {
  /// Scope should run echo on each of its children.
  void PrintEcho(std::ostream & os, const std::string & prefix) const override {
    os << code;
  }

  /// Scope should run output on each of its children.
  void PrintOutput(std::ostream & os, const std::string & prefix) const override {
    os << code;
  }
};

struct AST_Namespace : public AST_Scope {
  std::string name;

  /// Scope should run echo on each of its children.
  void PrintEcho(std::ostream & os, const std::string & prefix) const override {
    os << prefix << "namespace" << " " << name << " {\n";
    for (auto x : children) { x->PrintEcho(os, prefix+"  "); }
    os << prefix << "}\n";      
  }

  /// Scope should run output on each of its children.
  void PrintOutput(std::ostream & os, const std::string & prefix) const override {
    os << prefix << "namespace" << " " << name << " {\n";
    for (auto x : children) { x->PrintOutput(os, prefix+"  "); }
    os << prefix << "}\n";      
  }
};

/// This AST node handles a class or struct definition.
/// @todo: Ideally this node should process the contents to allow concepts in classes.
struct AST_Class : public AST_Node {
  std::string type = "class";
  std::string name = "";
  std::string body = "";

  /// Scope should run echo on each of its children.
  void PrintEcho(std::ostream & os, const std::string & prefix) const override {
    os << prefix << type << " " << name << "{\n" << prefix << "  " << body << "};\n";
    // os << prefix << type << " " << name << "{\n";
    // for (auto x : children) { x->PrintEcho(os, prefix+"  "); }
    // os << prefix << "};\n";      
  }

  /// Scope should run output on each of its children.
  void PrintOutput(std::ostream & os, const std::string & prefix) const override {
    os << prefix << type << " " << name << "{\n" << prefix << "  " << body << "};\n";
    // os << prefix << "namespace" << " " << name << "{\n";
    // for (auto x : children) { x->PrintOutput(os, prefix); }
    // os << prefix << "};\n";      
  }
};

/// AST Node for outer level using statement...
struct AST_Element : AST_Node {
  ElementInfo info;

  void PrintEcho(std::ostream & os, const std::string & prefix) const override {
    info.PrintEcho(os, prefix);
  }

  /// Output for a using should be identical to the input.
  void PrintOutput(std::ostream & os, const std::string & prefix) const override {
    info.PrintEcho(os, prefix);
  }
};

/// AST Node for concept information.
struct AST_Concept : AST_Node {

  std::string name;
  std::string base_name;

  emp::vector<ElementInfo> members;


  void PrintEcho(std::ostream & os, const std::string & prefix) const override {
    // Open the concept
    os << prefix << "concept " << name << " : " << base_name << " {\n";

    // Print info for all members
    for (auto & m : members) {
      m.PrintEcho(os, prefix+"  ");
      os << "\n";
    }

    // Close the concept
    os << prefix << "};\n";
  }

  void PrintOutput(std::ostream & os, const std::string & prefix) const override {
    os << prefix << "/// Base class for concept wrapper " << name << "<>.\n"
        << prefix << "class " << base_name << " {\n"
        << prefix << "public:\n";

    // Print all of the BASE CLASS details.
    for (auto & m : members) {
      m.PrintConceptBase(os, prefix+"  ");
      os << "\n";
    }

    os << prefix << "};\n\n";

    // Print all of the TEMPLATE WRAPPER details.
    os << prefix << "/// === Concept wrapper (base class is " << base_name << ") ===\n"
        << prefix << "template <typename WRAPPED_T>\n"
        << prefix << "class " << name << " : public WRAPPED_T, public " << base_name << " {\n"
        << prefix << "public:\n"
        << prefix << "  using this_t = " << name << "<WRAPPED_T>;\n\n";

    // Print concept info for all derived members
    for (auto & m : members) {
      m.PrintConceptDerived(os, prefix+"  ");
      os << "\n";
    }

    os << prefix << "};\n\n";
  }
};
