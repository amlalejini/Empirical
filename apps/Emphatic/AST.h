/**
 *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
 *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
 *  @date 2019
 *
 *  @file  AST.h
 *  @brief AST nodes generated by Emphatic.
 * 
 *  @todo If concept destructor is defined, override default below.
 **/

#include "ElementInfo.h"

/// All AST Nodes have a common base class.
struct AST_Node {
  std::string name = "";  ///< All nodes should have a name (to match their identifier) for easy lookup later.

  virtual ~AST_Node() { ; }
  /// Echo the original code passed into each class.
  virtual void PrintEcho(std::ostream &, const std::string & prefix) const = 0;
  virtual void PrintOutput(std::ostream &, const std::string & prefix) const = 0;

  virtual bool IsScope() const { return false; }
  virtual bool IsCode() const { return false; }
  virtual bool IsPP() const { return false; }
  virtual bool IsNamespace() const { return false; }
  virtual bool IsClass() const { return false; }
  virtual bool IsElement() const { return false; }
  virtual bool IsConcept() const { return false; }
};

/// AST Node for a new scope level.
struct AST_Scope : AST_Node {
  emp::vector<emp::Ptr<AST_Node>> children;
  ~AST_Scope() { for (auto x : children) x.Delete(); }

  /// Create a new child (of a specified type) in this scope.
  template <typename T>
  T & NewChild() {
    auto node_ptr = emp::NewPtr<T>();  ///< Build the new AST node.
    children.push_back(node_ptr);      ///< Save it as a child in the current scope.
    return *node_ptr;                  ///< Return a reference to the new child.
  }

  /// Scope should run echo on each of its children.
  void PrintEcho(std::ostream & os, const std::string & prefix) const override {
    for (auto node : children) { node->PrintEcho(os, prefix); }
  }

  /// Scope should run output on each of its children.
  void PrintOutput(std::ostream & os, const std::string & prefix) const override {
    for (auto node : children) { node->PrintOutput(os, prefix); }
  }

  emp::Ptr<AST_Node> GetChild(const std::string & node_name) const {
    for (auto node : children) { if (node->name == node_name) return node; }
    return nullptr;
  }

  bool IsScope() const { return true; }
};

/// AST Node for arbitrary code (these shouldn't be needed when parsing techniques improve)
struct AST_Code : public AST_Node {
  std::string code;

  /// Scope should run echo on each of its children.
  void PrintEcho(std::ostream & os, const std::string & prefix) const override {
    os << prefix << code;
  }

  /// Scope should run output on each of its children.
  void PrintOutput(std::ostream & os, const std::string & prefix) const override {
    os << prefix << code;
  }

  bool IsCode() const { return true; }
};

/// AST Node for Pre-processor code. (These should probably be dealt with in a first pass)
struct AST_PP : public AST_Code {
  /// Scope should run echo on each of its children.
  void PrintEcho(std::ostream & os, const std::string & prefix) const override {
    os << code;
  }

  /// Scope should run output on each of its children.
  void PrintOutput(std::ostream & os, const std::string & prefix) const override {
    os << code;
  }

  bool IsPP() const { return true; }
};

struct AST_Namespace : public AST_Scope {
  /// Scope should run echo on each of its children.
  void PrintEcho(std::ostream & os, const std::string & prefix) const override {
    os << prefix << "namespace" << " " << name << " {\n";
    for (auto x : children) { x->PrintEcho(os, prefix+"  "); }
    os << prefix << "}\n";      
  }

  /// Scope should run output on each of its children.
  void PrintOutput(std::ostream & os, const std::string & prefix) const override {
    os << prefix << "namespace" << " " << name << " {\n";
    for (auto x : children) { x->PrintOutput(os, prefix+"  "); }
    os << prefix << "}\n";      
  }

  bool IsNamespace() const { return true; }
};

/// AST Node for outer level using statement...
struct AST_Element : AST_Node {
  ElementInfo info;

  void PrintEcho(std::ostream & os, const std::string & prefix) const override {
    info.PrintEcho(os, prefix);
  }

  /// Output for a using should be identical to the input.
  void PrintOutput(std::ostream & os, const std::string & prefix) const override {
    info.PrintEcho(os, prefix);
  }

  bool IsElement() const { return true; }
};

/// AST Node for concept information.
struct AST_Concept : AST_Node {
  std::string base_name = "";    ///< What is the name of the base class that will part of this template.
  bool base_predefined = false;  ///< Have other aspects of the base class already been defined?

  emp::vector<ElementInfo> members;


  void PrintEcho(std::ostream & os, const std::string & prefix) const override {
    // Open the concept
    os << prefix << "concept " << name << " : " << base_name << " {\n";

    // Print info for all members
    for (auto & m : members) {
      m.PrintEcho(os, prefix+"  ");
      os << "\n";
    }

    // Close the concept
    os << prefix << "};\n";
  }

  void PrintOutput(std::ostream & os, const std::string & prefix) const override {
    // If the base class hasn't previously been defined, do so here.
    if (base_predefined == false) {
      os << prefix << "/// Base class for concept wrapper " << name << "<>.\n"
          << prefix << "class " << base_name << " {\n"
          << prefix << "public:\n"
          << prefix << "  virtual ~" << base_name << "() { ; }\n";

      // Print all of the BASE CLASS details.
      for (auto & m : members) {
        m.PrintConceptBase(os, prefix+"  ");
        os << "\n";
      }

      os << prefix << "};\n\n";
    }

    // Print all of the TEMPLATE WRAPPER details.
    os << prefix << "/// === Concept wrapper (base class is " << base_name << ") ===\n"
        << prefix << "template <typename WRAPPED_T>\n"
        << prefix << "class " << name << " : public WRAPPED_T, public " << base_name << " {\n"
        << prefix << "public:\n"        
        << prefix << "  using this_t = " << name << "<WRAPPED_T>;\n"
        << prefix << "  using wrapped_t = WRAPPED_T;\n"
        << prefix << "  template <typename... ARGS>\n"
        << prefix << "  " << name << "(ARGS... args) : WRAPPED_T(std::forward<ARGS>(args)...) {;}\n\n";

    // Print concept info for all derived members
    for (auto & m : members) {
      m.PrintConceptDerived(os, prefix+"  ");
      os << "\n";
    }

    os << prefix << "};\n\n";
  }

  bool IsConcept() const { return true; }
};

/// This AST node handles a class or struct definition.
/// @todo: Ideally this node should process the contents to allow concepts in classes.
struct AST_Class : public AST_Node {
  std::string type = "class";
  std::string base_info = "";
  std::string body = "[[declaration]]";
  emp::vector<emp::Ptr<AST_Concept>> concepts; ///< Which concepts does this class need to be base for?

  /// Scope should run echo on each of its children.
  void PrintEcho(std::ostream & os, const std::string & prefix) const override {
    if (body == "[[declaration]]") {
      os << prefix << type << " " << name << ";\n";
    } else {
      os << prefix << type << " " << name << base_info << "{\n"
         << prefix << "  " << body << "\n"
         << prefix << "};\n";
    }
    // os << prefix << type << " " << name << "{\n";
    // for (auto x : children) { x->PrintEcho(os, prefix+"  "); }
    // os << prefix << "};\n";      
  }

  /// Scope should run output on each of its children.
  void PrintOutput(std::ostream & os, const std::string & prefix) const override {
    if (body == "[[declaration]]") {  // This is just a declaration...
      os << prefix << type << " " << name << ";\n";
    }

    else {
      // Do the basic definition of this class.
      os << prefix << type << " " << name << base_info << "{\n";
      os << prefix << "  " << body << "\n";

      // If this class is being used as a base clase for any concepts, include the concept code here.
      if (concepts.size()) os << prefix << "public:\n";

      // Setup virtual destructor.
      // @CAO: This should probably not be here?  Only in concepts.
      os << prefix << "virtual ~" << name << "() { ; }\n";

      for (auto concept : concepts) {
        // Print all of the BASE CLASS details for each concept.
        for (auto & m : concept->members) {
          m.PrintConceptBase(os, prefix+"  ");
          os << "\n";
        }
      }

      os << prefix << "};\n";
      // os << prefix << "namespace" << " " << name << "{\n";
      // for (auto x : children) { x->PrintOutput(os, prefix); }
      // os << prefix << "};\n";      
    }
  }

  bool IsClass() const { return true; }
};
